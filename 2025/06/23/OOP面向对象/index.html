<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		OOP面向对象 | 
	 
	Hexo
	</title>
	
	<!-- keywords,description -->
	
	

	<!-- favicon -->
	


	<!-- search -->
	<script>
		var searchEngine = "";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
	

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
    

    

    

    
  
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="Press Enter to search">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2025/06/17/13%20%20%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">
                     
										    13  五大经典算法
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2025/06/23/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">
                     
										    OOP面向对象
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2025/06/17/hell0/">
                     
										    hell0
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2025/06/17/hello-world/">
                     
										    hello-world
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content" class="content">
		<h1 id="article-title">
	OOP面向对象
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>John Doe</span>
	<span>2025-06-23 19:48:52</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<p>方法调用：</p>
<p>有static，可直接用类名调用<br>无static，需要实例化对象，才能调用</p>
<p>一个Java类中可以有多个class类，但是只能有一个public class 类</p>
<blockquote>
<p>匿名对象<br>new Student().func();   &#x2F;&#x2F;没有名字的初始化类，不用将实例保存在变量中</p>
</blockquote>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>高内聚，低耦合</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>public  class  Student  extends  Person{<br>可继承public和protected<br>无法访问private<br>}</p>
<blockquote>
<p>this指向自己<br>super指向父类<br>子类中隐含——super();   &#x2F;&#x2F;调用父类的构造器，必须要在子类构造器的第一行<br>父类只有有参构造时，子类无法进行无参构造——父类保留无参构造</p>
</blockquote>
<p>super注意点：</p>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一行</li>
<li>super必须只能出现在子类的方法或者构造方法中</li>
<li>super和this不能同时调用构造方法（因为他们都必须在第一行，但只有一个第一行）</li>
</ul>
<p>VS this：</p>
<ul>
<li>this本身调用这个对象  super：父类对象的引用</li>
<li>this没有继承也可以使用  super只能在继承条件下才能用</li>
<li>this：本类的构造    super:父类的构造</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>父类的引用可以指向子类的实现<br>Farther  f&#x3D; new Son();</p>
<ul>
<li>静态方法（static），方法的调用只和左边的定义有关</li>
<li>子类重写了调用子类，反之调用父类</li>
<li>子类独有的方法，父类无法调用——可以使用强制转换((Son)f1).func();</li>
</ul>
<blockquote>
<p>子类重写父类的方法<br>方法名必须相同，参数列表必须相同<br>修饰符范围可以扩大——private-&gt;protected-&gt;public<br>抛出异常，范围的可以被缩小，不能扩大</p>
</blockquote>
<p>Alt+Insert</p>
<h2 id="多肽"><a href="#多肽" class="headerlink" title="多肽"></a>多肽</h2><ul>
<li>多肽是方法的多肽</li>
<li>父类和子类有联系     类型转换异常——ClassCastException！</li>
<li>继承      重写方法    父类引用指向子类</li>
<li></li>
</ul>
<p>无法重写</p>
<ul>
<li>static方法——属于类，不属于实例</li>
<li>final常量</li>
<li>private方法</li>
</ul>
<table>
<thead>
<tr>
<th>Person p&#x3D;new Student();</th>
<th>Student stu &#x3D; new Student();</th>
</tr>
</thead>
<tbody><tr>
<td>父类+子类重写</td>
<td>父类继承+子类all</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>用父类引用 (<code>Person p</code>)</strong>：<br>  当需要统一处理不同子类（如 <code>Student</code>, <code>Teacher</code> 都是 <code>Person</code>），且只需调用父类共有的方法时。</p>
</li>
<li><p><strong>用子类引用 (<code>Student stu</code>)</strong>：<br>  当需要直接操作子类特有的属性或方法时。</p>
</li>
</ul>
<h3 id="向下转型的风险"><a href="#向下转型的风险" class="headerlink" title="向下转型的风险"></a>向下转型的风险</h3><p>如果尝试将 <code>Person p</code> 转为 <code>Student</code>，但实际对象不是 <code>Student</code> 实例，会抛出 <code>ClassCastException</code>：<br>Person p &#x3D; new Person();<br>Student stu &#x3D; (Student)p;  &#x2F;&#x2F; 运行时错误！</p>
<p>安全做法是先使用 <code>instanceof</code> 检查——判断某个对象是否为某个类的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;       <span class="comment">//创建p的时候，是否是new的Student</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)p;    <span class="comment">//强转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>instanceof</code> 要求两个类在同一个继承链上</strong>（父子类关系或接口实现关系）       Person  instanceof   String     &#x2F;&#x2F;无父子关系编译报错</p>
<blockquote>
<p>((Student)p).func       &#x2F;&#x2F;强转换之后可以子类独有的方法了     两个括号</p>
</blockquote>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><pre><code>静态变量/方法可以通过类直接调用，非静态必须先实例化对象才能调用
非静态方法可以调用静态方法，静态方法只能调用静态方法
static随类一起加载，非静态随实例一起加载
</code></pre>
<h4 id="匿名代码块"><a href="#匿名代码块" class="headerlink" title="匿名代码块"></a>匿名代码块</h4><p>执行顺序：    静态匿名代码块  -&gt;  匿名代码块  -&gt; 构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    <span class="comment">//静态匿名代码块   永久只执行一次  可以用于加载初始数据</span></span><br><span class="line">&#125;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//匿名代码块  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="comment">//构造方法  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import  java.lang.Math.random   //报错</span></span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">static</span> java.lang.Math.random   <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI</span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>被final修饰的类无法创造子类&#x2F;&#x2F;断子绝孙常量修饰符</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="comment">//约束~只写框架，由子类实现  </span></span><br><span class="line">    <span class="comment">//abstract,抽象方法，只有方法名字，没有方法实现  </span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title function_">func</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类的所以方法，继承它的子类，都必须实现它的方法，除非子类也是抽象类abstract  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> <span class="keyword">extends</span> <span class="title class_">Main</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类不能new出来，只能靠子类去实现</li>
<li>抽象类中可以写普通方法，但抽象方法只能写在抽象类</li>
</ul>
<p>&#96;&#96;</p>
<h1 id="接口-——-interface"><a href="#接口-——-interface" class="headerlink" title="接口 —— interface"></a>接口 —— interface</h1><p>类只能单继承（一个爸爸），但接口可以多继承。</p>
<pre><code>接口——只有规范，无法自己写方法，专业的约束，约束和实现分离：面向接口编程
接口的本质是契约（法律）
设计模式——如何合理地去抽象
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口都需要有实现类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="comment">//接口中所有的定义都是抽象的 public  abstract    void func(String name);     //等同于public  abstract void func();  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">query</span><span class="params">(String name)</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService2</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>,UserService2&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口中的方法都是public abstract<br>接口中的常量都是public abstract final    &#x2F;&#x2F;不常写常量<br>接口不能被实例化，接口中没有构造方法</p>
</blockquote>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;外部类&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;内部类&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//生成外部类  </span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();  </span><br><span class="line">        <span class="comment">//生成内部类  </span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">in1</span> <span class="operator">=</span> out1.<span class="keyword">new</span> <span class="title class_">Inner</span>();  </span><br><span class="line">        in1.in();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内部类可以获得外部类的私有属性</li>
<li>内部类可以获得外部类的方法和属性，不需要实例化外部类</li>
</ul>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><pre><code>静态内部类不可以访问外部非静态属性
</code></pre>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">infunc</span>&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    A a=<span class="keyword">new</span> <span class="title class_">A</span>()&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">facefunc</span><span class="params">()</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">interface</span>  <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">facefunc</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       Animal a= <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;  </span><br><span class="line">           <span class="meta">@Override</span>  </span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;  </span><br><span class="line">               System.out.println(<span class="string">&quot;小猫喵喵喵&quot;</span>);  </span><br><span class="line">           &#125;  <span class="comment">//创建匿名子类并实例化</span></span><br><span class="line">       &#125;;  </span><br><span class="line">        a.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>(x)-&gt;2x+1</p>
<pre><code>(参数) -&gt; &#123; 函数体 &#125;  // 单行可省略大括号和 return
</code></pre>
<ul>
<li>参数类型可以不写</li>
<li>只有一个参数可以不写（）</li>
<li>只有一行代码可以不写{}，同时省略‘；’，如果是return，必须去掉return</li>
</ul>
<p>只能简化<strong>函数式接口</strong>的匿名内部类——只有一个抽象方法的接口</p>
<p>eg——button.addActionListener(e -&gt; System.out.println(“按钮被点击了！”));</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       Animal a= () -&gt; System.out.println(<span class="string">&quot;小猫喵喵喵&quot;</span>);  </span><br><span class="line">       a.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h4><p>Integer.compare(int x, int y)是 Java 提供的一个静态方法，用于比较两个 int值的大小关系。它的返回值遵循以下规则：</p>
<ul>
<li>如果 x &lt; y，返回 -1</li>
<li>如果 x &#x3D;&#x3D; y，返回 0</li>
<li>如果 x &gt; y，返回 1</li>
</ul>
<p>类似的方法：</p>
<ul>
<li><p>Double.compare(double d1, double d2)&#96;</p>
</li>
<li><p>Long.compare(long l1, long l2)&#96;</p>
</li>
<li><p>Float.compare(float f1, float f2)&#96;</p>
</li>
<li><p><strong><code>Comparator.comparingInt(Person::getAge)</code></strong> → <strong>升序（从小到大）</strong></p>
</li>
<li><p><strong><code>Comparator.comparingInt(Person::getAge).reversed()</code></strong> → <strong>降序（从大到小）</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序：a - b</span></span><br><span class="line">Comparator&lt;Person&gt; ascending = (p1, p2) -&gt; p1.getAge() - p2.getAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">List&lt;Person&gt; people = ...;</span><br><span class="line">people.sort(ascending);  <span class="comment">// 按年龄升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序：b - a</span></span><br><span class="line">Comparator&lt;Person&gt; descending = (p1, p2) -&gt; p2.getAge() - p1.getAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">List&lt;Person&gt; people = ...;</span><br><span class="line">people.sort(descending);  <span class="comment">// 按年龄降序排序</span></span><br></pre></td></tr></table></figure>
<p>o1.compareToIgnoreCase(o2)——忽略大小写比较字符串</p>
<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p><code>Predicate</code> 是 Java 8 引入的一个 <strong>函数式接口（Functional Interface）</strong>，位于 <code>java.util.function</code> 包中。它主要用于 <strong>条件判断</strong>，接收一个输入参数，返回一个 <code>boolean</code> 值（<code>true</code> 或 <code>false</code>）。</p>
<p>内置函数式接口，Lambda表达式可以直接匿名调用</p>
<p>numbers.removeIf(n -&gt; n % 2 !&#x3D; 0);   removeif的参数就是Predicate</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h3 id="静态方法的引用——类：：方法名"><a href="#静态方法的引用——类：：方法名" class="headerlink" title="静态方法的引用——类：：方法名"></a>静态方法的引用——类：：方法名</h3><p>如果某个Lambda表达式里只是调用一个静态方法，并且“ -&gt; ”前后参数形式一致，就可以使用静态方法引用</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>Array.sort(student,(o1,o2)-&gt;o1.getAge()-o2.getAge())</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Array.sort(student,(o1,o2)-&gt;student.compare(o1,o2))</td>
</tr>
<tr>
<td>静态方法引用</td>
<td>Array.sort(student,student::compare)</td>
</tr>
</tbody></table>
<h3 id="实例方法的引用——实例对象：：方法名"><a href="#实例方法的引用——实例对象：：方法名" class="headerlink" title="实例方法的引用——实例对象：：方法名"></a>实例方法的引用——实例对象：：方法名</h3><p>如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“ -&gt; ”前后参数形式一致，就可以使用实例方法引用<br>student t&#x3D;new student();</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>Array.sort(student,(o1,o2)-&gt;t.compare(o1,o2)</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>Array.sort(student,t::compare)</td>
</tr>
</tbody></table>
<h3 id="特点类型方法的引用——类型名称：：方法名"><a href="#特点类型方法的引用——类型名称：：方法名" class="headerlink" title="特点类型方法的引用——类型名称：：方法名"></a>特点类型方法的引用——类型名称：：方法名</h3><p>如果一个Lambda表达式只是调用一个特定类型的实例方法，并且前面的参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参，则此时就可以使用特定的方法引用</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>Array.sort(name,(o1,o2)-&gt;o1.compareToIgnoreCase(o2)</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>Array.sort(name , String::compareToIgnoreCase)</td>
</tr>
</tbody></table>
<h3 id="构造器引用——类名：：new"><a href="#构造器引用——类名：：new" class="headerlink" title="构造器引用——类名：：new"></a>构造器引用——类名：：new</h3><table>
<thead>
<tr>
<th>Lambda</th>
<th>Car Factory   cf&#x3D;name -&gt;  new Car(name)</th>
</tr>
</thead>
<tbody><tr>
<td>静态方法引用</td>
<td>Car Factory   cf&#x3D;car::new</td>
</tr>
</tbody></table>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/2025/06/17/13%20%20%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">
                13  五大经典算法
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>

	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>

	
	    <a href="/">John Doe</a>
	
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//wujun.me" target="_blank">Wu Jun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>